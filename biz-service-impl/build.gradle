// 只要有这两个"应用插件"，本模块总可以以 Spring Boot 的模式启动起来，不需要在 root project 里面对所有的 subprojects 进行 apply
//apply plugin: 'org.springframework.boot'
//apply plugin: 'io.spring.dependency-management'

dependencies {
    // compile（api）：这种是我们最常用的方式，使用该方式依赖的库将会参与编译和打包。也就是最简单的 dependency
    api project(":biz-shared")
    api project(":common-service-facade")

    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-devtools'
    implementation 'org.springframework.boot:spring-boot-starter-web'

    testImplementation 'io.projectreactor:reactor-test'
}

// 这个名字是插件的函数的名字，也是 task，特定的插件的 task 名字是不一样的
bootJar {
    enabled = true
}

// 如果找不到 application 主类，则使用如下配置指定主类

//plugins {
//    id 'application'
//}
// mainClassName = 'com.MyApplication'


jar {
    enabled = true
}

// 在这里只是做了一个小小的修改，让 test 拥有自己的两个 source src，然后它天然的 classpath、test task 都复用原来的（没有单独的 integration task），如果有必要需要单独 filter test 来使用测试
sourceSets {
    test.java.srcDirs = ['src/test/integration/java', 'src/test/unit/java']
}

//sourceSets {
//    main {
//        java {
//            srcDirs = ['src']
//        }
//    }
//
//    test {
//        java {
//            srcDirs = ['test']
//        }
//    }
//
//    integrationTest {
//        java {
//            compileClasspath += main.output + test.output
//            runtimeClasspath += main.output + test.output
//            srcDir file('src/integration-test/java')
//        }
//        resources.srcDir file('src/integration-test/resources')
//    }
//}
//
//task integrationTest(type: Test) {
//    testClassesDirs = sourceSets.integrationTest.output.classesDirs
//    classpath = sourceSets.integrationTest.runtimeClasspath
//}