package algorithm.sort;

/**
 * project name: domain-driven-transaction-sys
 *
 * description: 插入排序
 *
 * 这是第一种构造型的排序算法，从小的数组开始，逐渐构造更好的数据结构。编程珠玑里面比较过，只有比较（但是比较又不是比较相邻的数据，而是比较最大的数据）位移-类似逆向冒泡的做法来实现插入是性能最好的。
 *
 * @author magicliang
 *
 *         date: 2025-08-21 15:53
 */
public class InsertionSort {

    /**
     * 插入排序实现 - 优化版本
     *
     * 算法思路：
     * 1. 维护已排序区间[0, i-1]和未排序区间[i, n-1]
     * 2. 每轮取出未排序区间的第一个元素nums[i]
     * 3. 在已排序区间中从右向左寻找插入位置，同时后移较大元素
     * 4. 找到位置后统一插入元素
     *
     * 时间复杂度：O(n²) 最坏情况，O(n) 最好情况(已排序)
     * 空间复杂度：O(1) 原地排序
     * 稳定性：稳定排序算法
     *
     * @param nums 待排序的整数数组
     */
    public void insertionSort(int[] nums) {
        // 边界条件检查
        if (nums == null || nums.length == 0) {
            return;
        }
        int n = nums.length;

        // 外层循环：处理每个未排序元素
        // 从索引1开始，因为单个元素nums[0]天然有序
        for (int i = 1; i < n; i++) {
            // 保存当前要插入的元素值
            int tmp = nums[i];

            // 🔑 关键改进：将j声明在循环外，以便后续使用其最终值
            int j;

            // 内层循环：在已排序区间[0, i-1]中寻找插入位置
            // 从右向左扫描，将所有大于tmp的元素右移一位
            for (j = i - 1; j >= 0; j--) {
                // 假定前面的区间是已排序数组
                if (nums[j] > tmp) {
                    // 后退：将大于tmp的元素向右移动一位，为插入腾出空间
                    // 这个操作不会丢失数据，因为nums[j+1]要么是tmp的备份，要么已经被处理过
                    nums[j + 1] = nums[j];
                } else {

                    // 易错的点：在这里执行  nums[j + 1] = tmp;。这里有一个bug，就是也许整个数组i的全部部分都大于 tmp，在 nums[0] 执行上一个 nums[j + 1] =
                    // nums[j];，却不执行到这一步
                    break; // 易错的点：忘记提前退出
                }
            }

            // 🎯 统一插入策略：无论循环如何结束，j+1都是正确的插入位置
            // 走到这一步，要么完全没有更大的值，那么tmp在原地插入，要么在上一个 j 处插入
            //
            // 两种情况分析：
            // 情况1：break退出 → j指向最后一个 <= tmp 的位置 → j+1是插入位置 ✓
            // 情况2：j=-1退出 → 所有元素都 > tmp → j+1=0是插入位置 ✓

            // 这样写才是必须执行的
            // 走到这一步，要么完全没有更大的值，那么tmp在原地插入，要么在上一个 j 处插入
            nums[j + 1] = tmp;

            // 循环不变式：每轮结束后 [0, i] 区间保持有序
        }
    }
}
